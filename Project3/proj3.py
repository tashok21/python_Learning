from scipy.optimize import fsolve
import matplotlib.pyplot as plt
import numpy as np
import scipy.constants as ct
from scipy.optimize import leastsq
import warnings

# Constants required for calculation
n_constant = 1.7  # Ideality factor
R_constant = 11e3  # Resistor value in series with diode
T_coeff1 = 350  # Temperature coefficient: Problem 1
T_coeff2 = 375  # Temperature coefficient: Problem 2
ISat_constant = 1e-9  # Saturation current of the diode
q = ct.physical_constants["atomic unit of charge"][0]  # atomic unit of charge value
k = ct.physical_constants["Boltzmann constant"][0]  # Boltzmann constant
A = 1e-8  # Area of cross-section of the diode
RES_ERR_THRESH = 10e-5  # Initial residual threshold for the diode current
res_avg = 1

# Ignore the warnings generated by leastsq operations
warnings.simplefilter("ignore")

# Problem 1
# to initialize the voltage range for the diode
Vs_init = np.arange(0.1, 2.5, 0.1)  # voltage range of 0.1 V to 2.5 V with step size of 0.1(given)
step_size = (2.5 - 0.1) / 0.1
V = [1 for i in range(int(step_size + 1))]  # Creates a list with step_size number of 1000's


# the diode equation
def diode_current_1(Vd, Is, n, T):
    return Is * (np.exp((Vd * q) / (n * k * T)) - 1)  # Returns Is=current through the diode


# equation for nodal analysis on the circuit
# Err value should be 0 when the value of V and Vd are correctly chosen
def errorFunc(Vd, V, R, Is, n, T):
    Err = (Vd / R) - (V / R) + diode_current_1(Vd, Is, n, T)
    return Err


# to find the voltage across the diode that gives the least error
diode_voltage = fsolve(errorFunc, V, args=(Vs_init, R_constant, ISat_constant, n_constant, T_coeff1))
diode_current = diode_current_1(diode_voltage, ISat_constant, n_constant, T_coeff1)

# plot
fig, (axis1, axis2) = plt.subplots(1, 2, figsize=(15, 7))
axis1.set_title("Problem 1")
axis1.set_ylabel("log (Diode current)")
axis1.set_xlabel("Voltage in volts")

axis1.plot(Vs_init, np.log10(diode_current),
           label="Source Voltage")  # Plot between the source voltage and diode current
axis1.plot(diode_voltage, np.log10(diode_current),
           label="Diode Voltage")  # Plot between diode voltage and diode current
axis1.legend()  # to include the legends in the plot

# Problem 2
# parameters unknown
# constants are initialised as array so as to get the output currents in array
# given constants
n = [1.5]  # Ideality factor of the diode
R = [10e3]  # Resistance in series with the diode
phi = [0.8]  # Barrier height for the diode

f = open("DiodeIV.txt", 'r')  # to read a text file in python
lines = f.readlines()  # Read the text file line by line

# Initialize the values of source voltages and diode currents as lists
Vs_list = []
Id_list = []  # current through diode

for line in lines:
    a = line.strip().split()
    Vs_list.append(a[0])
    Id_list.append(a[1])

# to convert list of strings to an array for calculations
Vs_arr = [float(i) for i in Vs_list]
Id_arr = [float(i) for i in Id_list]


# Diode current equation
# Vd = Vs - (I * R)
def diode_current_2(Is, Vs, R, n, I):
    return Is * (np.exp((((Vs - (I * R)) * q) / (n * k * T_coeff2))) - 1)


# Define the equation for the saturation current of the diode
def I_saturation(phi):
    return (A * (T_coeff2 ** 2) * np.exp(-phi * q / (k * T_coeff2)))


# Define the residual functions
# objective is to find the actual values for Phi, Ideality, and the Resistor
# identical residual functions
def residual_phi(phi, n, R):
    Is_temp = I_saturation(phi)
    return np.absolute(Id_arr - diode_current_2(Is_temp, Vs_arr, R, n, Id_arr))


def residual_n(n, phi, R):
    Is_temp = I_saturation(phi)
    return np.absolute(Id_arr - diode_current_2(Is_temp, Vs_arr, R, n, Id_arr))


def residual_R(R, n, phi):
    Is_temp = I_saturation(phi)
    return np.absolute(Id_arr - diode_current_2(Is_temp, Vs_arr, R, n, Id_arr))


# Use a loop until the desired value converges to an accurate value within an error
# threshold
# Use count to keep track of the number of iterations before the convergence
count = 1

while (res_avg > RES_ERR_THRESH):
    # least squares optimization to get the values of R, phi and n
    R = leastsq(residual_R, R[0], args=(n[0], phi[0]))
    # print("LeastSq (R): " + str(R))
    phi = leastsq(residual_phi, phi[0], args=(n[0], R[0]))
    # print("LeastSq: (phi)" + str(R[0]))
    n = leastsq(residual_n, n[0], args=(phi[0], R[0]))

    # average size of the errors at each data point
    # Get the average residual
    res_avg = np.average(np.absolute(residual_phi(phi[0], n[0], R[0])))

    # Tracking parameters
    print("< Iter#: {0} ; phi: {1:.4f} ; n: {2:.4f} ; R: {3:.2f} ; Residual: {4:.3e} >" \
          .format(count, phi[0][0], n[0][0], R[0][0], res_avg))

    # Increment the tracking count for every iteration
    count += 1

# Indexed predicted values
R_pred = R[0][0]
n_pred = n[0][0]
phi_pred = phi[0][0]


#  print the iteration number and the values of the 3 parameters to track the progress following each iteration
print("\n\nEstimated resistance (R): {0:.2f} \u03A9".format(R_pred))
print("Estimated ideality factor (n): {0:.2f}".format(n_pred))
print("Estimated phi: {0:.3f}".format(phi_pred))
print("Number of iterations to converge: {0}".format(count))

# Initialise the diode voltage for prediction
Vd_init = [1 for i in range(len(Vs_arr))]

# saturation current, diode voltage, diode current based upon predicted values of phi
Is_pred = I_saturation(phi_pred)
predicted_diode_voltage = fsolve(errorFunc, Vd_init, args=(Vs_arr, R_pred, Is_pred, n_pred, T_coeff2))
predicted_diode_current = diode_current_1(predicted_diode_voltage, Is_pred, n_pred, T_coeff2)

# Plot
axis2.set_xlabel("Source voltage in volts")
axis2.set_ylabel("log (Diode current)")
axis2.set_title("Problem 2")

# Plot of source voltage and actual diode current
axis2.plot(Vs_arr[1:], np.log10(Id_arr[1:]), label="Actual")

# Plot of source voltage and predicted diode current
axis2.plot(Vs_arr[1:], np.log10(predicted_diode_current[1:]), label="Predicted")
axis2.legend()
plt.show()
